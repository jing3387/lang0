(in-package #:satori)

(defun closure-convert (x)
  (cond
    ((symbolp x) x)
    ((case (first x)
       (lambda (let* ((env (gensym))
                      (params (cons env (second x)))
                      (fv (free x))
                      (env* (pairlis fv fv))
                      (sub (map 'list
                                #'(lambda (x)
                                    `(,x . (env-ref ,env ,x)))
                                fv))
                      (body (substitute sub (rest (rest x)))))
                 `(make-closure (lambda* ,params ,body)
                                (make-env ,@env*))))
       (lambda* x)
       (make-closure x)
       (make-env x)
       (env-ref x)
       (apply-closure x)
       (t (if (= (length x) 1)
              (first x)
              (let ((f (first x))
                    (args (rest x)))
                `(apply-closure ,f . ,args))))))))

(defun flatten (structure)
  (cond
    ((null structure) nil)
    ((atom structure) (list structure))
    (t (mapcan #'flatten structure))))

(defun free (x)
  (cond
    ((symbolp x) (list x))
    ((case (first x)
       (lambda (let ((params (second x))
                     (body (rest (rest x))))
                 (set-difference (free body) params)))
       (lambda* (let ((params (second x))
                      (body (rest (rest x))))
                  (set-difference (free body) params)))
       (make-closure (let ((proc (second x))
                           (env (third x)))
                       (union (free proc) (free env))))
       (make-env (let ((es (mapcar #'cdr (rest x))))
                   (delete-duplicates (flatten (map 'list #'free es)))))
       (env-ref (let ((env (second x)))
                  (free env)))
       (apply-closure (let ((f (second x))
                            (args (rest (rest x))))
                        (delete-duplicates (flatten (map 'list #'free `(,f . ,args))))))
       (t (let ((f (first x))
                (args (rest x)))
            (delete-duplicates (flatten (map 'list #'free `(,f . ,args))))))))))

(defun substitute (sub x)
  (cond
    ((symbolp x) (if (assoc x sub)
                     (cdr (assoc x sub))
                     x))
    ((case (first x)
       (lambda (let* ((params (second x))
                      (body (rest (rest x)))
                      (sub* (map 'list
                                 #'(lambda (x)
                                     (let ((k (car x)))
                                       (when (not (member k params))
                                         x)))
                                 sub)))
                 `(lambda ,params ,@(substitute sub* body))))
       (lambda* (let* ((params (second x))
                       (body (rest (rest x)))
                       (sub* (map 'list
                                  #'(lambda (x)
                                      (let ((k (car x)))
                                        (when (not (member k params))
                                          x)))
                                  sub)))
                  `(lambda* ,params ,@(substitute sub* body))))
       (make-closure (let ((lam (second x))
                           (env (third x)))
                       `(make-closure ,(substitute sub lam) ,(substitute sub env))))
       (make-env (let ((vs (map 'list #'car (rest x)))
                       (es (map 'list #'cdr (rest x))))
                   `(make-env ,@(pairlis vs (map 'list
                                                 #'(lambda (x)
                                                     (substitute sub x))
                                                 es)))))
       (env-ref (let ((env (second x))
                      (v (third x)))
                  `(env-ref ,(substitute sub env) ,v)))
       (apply-closure (let ((f (second x))
                            (args (rest (rest x))))
                        `(apply-closure ,@(map 'list
                                               #'(lambda (x)
                                                   (substitute sub x))
                                               `(,f . ,args)))))
       (t (let ((f (first x))
                (args (rest x)))
            (map 'list #'(lambda (x) (substitute sub x)) `(,f . ,args))))))))

(defun transform-bottom-up (f x)
  (defun transform (x**) (transform-bottom-up f x**))
  (let ((x* (cond
              ((symbolp x) x)
              ((case (first x)
                 (lambda (let ((params (second x))
                               (body (rest (rest x))))
                           `(lambda ,params ,@(transform body))))
                 (lambda* (let ((params (second x))
                                (body (rest (rest x))))
                            `(lambda* ,params ,@(transform body))))
                 (make-closure (let ((lam (second x))
                                     (env (third x)))
                                 `(make-closure ,(transform lam) ,(transform env))))
                 (make-env (let ((vs (map 'list #'car (rest x)))
                                 (es (map 'list #'cdr (rest x))))
                             `(make-env ,@(pairlis vs
                                                   (map 'list #'transform es)))))
                 (env-ref (let ((env (second x))
                                (v (third x)))
                            `(env-ref ,(transform env) ,v)))
                 (apply-closure (let ((f (second x))
                                      (args (rest (rest x))))
                                  `(apply-closure ,(transform f)
                                                  ,@(map 'list #'transform args))))
                 (t (if (= (length x) 1)
                        (first x)
                        (let ((f (first x))
                              (args (rest x)))
                          `(,(transform f) ,@(map 'list #'transform args))))))))))
    (funcall f x*)))

(defun flat-closure-convert (x)
  (transform-bottom-up #'closure-convert x))

(defvar *builder*)
(defvar *module*)

(defun comp (x env)
  (cond
   ((symbolp x) (comp-var x env))
   ((case (first x)
      (lambda (comp-lambda (second x) (rest (rest x)) env))
      (t (comp-call (first x) (rest x) env))))))

(defun comp-var (var env))

(defun comp-lambda (args body env)
  (llvm:with-objects ((*builder* llvm:builder))))

(defun comp-call (f args env))
