(in-package #:satori)

(defvar *builder*)
(defvar *module*)
(defvar *execution-engine*)

(defun foreign-funcall-ptr (ty main ptr)
  (cond
    ((listp ty) nil)
    (t (case ty
         (<integer> (if (cffi:pointer-eq main ptr)
                        (llvm:generic-value-to-int
                         (llvm:run-function *execution-engine* ptr ()) t)
                        (cffi:foreign-funcall-pointer ptr () :int32)))))))

(defun execute (x)
  (llvm:with-objects ((*module* llvm:module "<unknown>")
                      (*builder* llvm:builder)
                      (*execution-engine* llvm:execution-engine *module*))
    (let* ((inference (infer x '() '()))
           (tenv (second inference))
           (ir1 (third inference))
           (ir2 (flat-closure-convert ir1))
           (retty (llvm-type (first inference) tenv))
           (param-types (make-array 0))
           (ftype (llvm:function-type retty param-types))
           (main (llvm:add-function *module* "" ftype)))
      (llvm:position-builder-at-end *builder*
                                    (llvm:append-basic-block main "entry"))
      (let* ((code (comp-in-main ir2 '() tenv)))
        (llvm:build-ret *builder* code)
        (llvm:verify-module *module*)
        (let* ((ptr (llvm:pointer-to-global *execution-engine* main))
               (result (foreign-funcall-ptr (first inference) main ptr)))
          result)))))

(defun jit ()
  (llvm:with-objects ((*module* llvm:module "<unknown>")
                      (*builder* llvm:builder)
                      (*execution-engine* llvm:execution-engine *module*))
    (format *error-output* "? ")
    (loop for x = (read *standard-input* nil 'eof nil)
          while (not (equal x 'eof)) do
            (let* ((inference (infer x '() '()))
                   (tenv (second inference))
                   (ir1 (third inference))
                   (ir2 (flat-closure-convert ir1))
                   (retty (llvm-type (first inference) tenv))
                   (param-types (make-array 0))
                   (ftype (llvm:function-type retty param-types))
                   (main (llvm:add-function *module* "" ftype)))
              (llvm:position-builder-at-end *builder*
                                            (llvm:append-basic-block main "entry"))
              (let* ((code (comp-in-main ir2 '() tenv)))
                (llvm:build-ret *builder* code)
                (llvm:verify-module *module*)
                (let* ((ptr (llvm:pointer-to-global *execution-engine* main))
                       (result (foreign-funcall-ptr (first inference) main ptr)))
                  (format *error-output* "~a~%" result))))
            (format *error-output* "? "))
    (llvm:dump-module *module*)))

(defun compiler ()
  (llvm:with-objects ((*module* llvm:module "<unknown>")
                      (*builder* llvm:builder))
    (let* ((param-types (make-array 0))
           (ftype (llvm:function-type (llvm:int32-type) param-types))
           (main (llvm:add-function *module* "main" ftype))
           (retval (comp '(<integer> 0) nil nil)))
      (llvm:position-builder-at-end *builder* (llvm:append-basic-block main "entry"))
      (let ((ret (llvm:build-ret *builder* retval)))
        (loop for x = (read *standard-input* nil 'eof nil)
              while (not (equal x 'eof)) do
                (llvm:position-builder-before *builder* ret)
                (let* ((inference (infer x '() '()))
                       (tenv (second inference))
                       (ir1 (third inference))
                       (ir2 (flat-closure-convert ir1)))
                  (comp-in-main ir2 '() tenv)
                  (llvm:dump-module *module*)
                  (llvm:verify-module *module*)))))))
