(in-package #:satori)

(defun substitute* (sub x)
  (cond
    ((symbolp x) (if (assoc x sub)
                     (cdr (assoc x sub))
                     x))
    ((integerp x) x)
    ((case (first x)
       (lambda (let* ((params (second x))
                      (retty (third x))
                      (body (rest (rest (rest x))))
                      (sub* (map 'list
                                 #'(lambda (x)
                                     (let ((k (car x)))
                                       (when (not (member k params))
                                         x)))
                                 sub)))
                 `(lambda ,params ,retty ,@(substitute* sub* body))))
       (let (let* ((vars (map 'list #'first (second x)))
                   (exps (map 'list #'second (second x)))
                   (sub* (map 'list
                              #'(lambda (x)
                                  (let ((k (car x)))
                                    (when (not (member k vars))
                                      x)))
                              sub))
                   (body (rest (rest x))))
              `(let ,(map 'list #'(lambda (var exp)
                                    `(,var ,(substitute* sub exp))) vars exps)
                 ,@(substitute* sub* body))))
       (lambda* (let* ((params (second x))
                       (retty (third x))
                       (body (rest (rest (rest x))))
                       (sub* (map 'list
                                  #'(lambda (x)
                                      (let ((k (car x)))
                                        (when (not (member k params))
                                          x)))
                                  sub)))
                  `(lambda* ,params ,retty ,@(substitute* sub* body))))
       (make-closure (let ((lam (second x))
                           (env (third x)))
                       `(make-closure ,(substitute* sub lam) ,(substitute* sub env))))
       (make-env (let ((id (second x))
                       (vs (map 'list #'car (rest (rest x))))
                       (es (map 'list #'cdr (rest (rest x)))))
                   `(make-env ,id ,@(pairlis vs (map 'list
                                                     #'(lambda (x)
                                                         (substitute* sub x))
                                                     es)))))
       (env-ref (let ((env (second x))
                      (v (third x))
                      (idx (fourth x)))
                  `(env-ref ,(substitute* sub env) ,v ,idx)))
       (apply-closure (let ((f (second x))
                            (args (rest (rest x))))
                        `(apply-closure ,@(map 'list
                                               #'(lambda (x)
                                                   (substitute* sub x))
                                               `(,f . ,args)))))
       (let* (let* ((vars (map 'list #'first (second x)))
                    (exps (map 'list #'second (second x)))
                    (sub* (map 'list
                               #'(lambda (x)
                                   (let ((k (car x)))
                                     (when (not (member k vars))
                                       x)))
                               sub))
                    (body (rest (rest x))))
               `(let* ,(map 'list #'(lambda (var exp)
                                      `(,var ,(substitute* sub exp))) vars exps)
                  ,@(substitute* sub* body))))
       (t (let ((f (first x))
                (args (rest x)))
            (map 'list #'(lambda (x) (substitute* sub x)) `(,f . ,args))))))))


(defun substitute-type (x constr)
  (cond
    ((null x) nil)
    ((not (listp x)) x)
    ((case (first x)
       (i32 x)
       (id (let ((type (assoc x constr :test #'equal)))
             (or (second type) x)))
       (variable
        (cond
          ((not (listp (third x))) x)
          ((case (first (third x))
             (lambda (let* ((type (third x))
                            (params (second type))
                            (params* (map 'list
                                          #'(lambda (x)
                                              (substitute-type x constr))
                                          params))
                            (retty (or (second (assoc (third type) constr))
                                       (third type)))
                            (type* (substitute-type `(lambda ,params* ,retty) constr)))
                       `(variable ,(second x) ,type*)))
             (t (let ((type (assoc (third x) constr :test #'equal)))
                  (if type
                      `(variable ,(second x) ,(second type))
                      x)))))))
       (lambda (let* ((params (second x))
                      (retty (substitute-type (third x) constr))
                      (body (rest (rest (rest x))))
                      (params* (map 'list
                                    #'(lambda (x)
                                        (substitute-type x constr))
                                    params))
                      (body* (map 'list
                                  #'(lambda (x)
                                      (substitute-type x constr))
                                  body)))
                 `(lambda ,params* ,retty ,@body*)))
       (let (let* ((vars (map 'list #'first (second x)))
                   (exps (map 'list #'second (second x)))
                   (body (rest (rest x)))
                   (vars* (map 'list #'(lambda (x) (substitute-type x constr)) vars))
                   (exps* (map 'list #'(lambda (x) (substitute-type x constr)) exps))
                   (bindings (map 'list #'(lambda (var exp) `(,var ,exp)) vars* exps*))
                   (body* (map 'list #'(lambda (x) (substitute-type x constr)) body)))
              `(let ,bindings ,@body*)))
       (t (let* ((f (first x))
                 (args (rest x))
                 (f* (substitute-type f constr))
                 (args* (map 'list #'(lambda (x) (substitute-type x constr)) args)))
            `(,f* ,@args*)))))))
