;; See: http://matt.might.net/articles/closure-conversion/

(in-package #:satori)

(defun closure-convert (x)
  (case (first x)
    (i32 x)
    (variable x)
    (lambda% (let* ((params (second x))
                    (env-var (first params))
                    (retty (third x))
                    (body (rest (rest (rest x))))
                    (fv (sort-symbols< (free x)))
                    (env (pairlis fv fv))
                    (idx 0)
                    (sub (map 'list
                              #'(lambda (x)
                                  (let ((sub `(,x . (env-ref ,env-var ,x ,idx))))
                                    (setf idx (1+ idx))
                                    sub))
                              fv))
                    (body* (substitute* sub body)))
               `(make-closure (lambda* ,params ,retty ,@body*)
                              (make-env ,env-var ,@env))))
    (let% x)
    (define% x)
    (lambda* x)
    (make-closure x)
    (make-env x)
    (env-ref x)
    (apply-closure x)
    (let* x)
    (define* x)
    (t (let ((f (first x))
             (args (rest x)))
         `(apply-closure ,f ,@args)))))

(defun free (x)
  (cond
    ((integerp x) '())
    ((symbolp x) (list x))
    ((case (first x)
       (nil nil)
       (lambda (let* ((params (second x))
                      (body (rest (rest x))))
                 (set-difference (free body) params)))
       (let (let* ((vars (second x))
                   (vars* (map 'list #'first vars))
                   (body (rest (rest x))))
              (set-difference (free body) vars*)))
       (i32 nil)
       (variable (list (free (second x))))
       (lambda% (let* ((params (second x))
                       (body (rest (rest (rest x))))
                       (params* (map 'list #'second params)))
                  (set-difference (free body) params*)))
       (let% (let* ((vars (map 'list #'first (second x)))
                    (vars* (map 'list #'second vars))
                    (body (rest (rest x))))
               (set-difference (free body) vars*)))
       (define% (let ((name (second (second x)))
                      (exp (third x)))
                  (set-difference (free exp) (list name))))
       (lambda* (let* ((params (second x))
                       (body (rest (rest (rest x))))
                       (params* (map 'list #'second params)))
                  (set-difference (free body) params*)))
       (make-closure (let ((proc (second x))
                           (env (third x)))
                       (union (free proc) (free env))))
       (make-env (let ((es (mapcar #'cdr (rest (rest x)))))
                   (delete-duplicates (flatten (map 'list #'free es)))))
       (env-ref '())
       (apply-closure (let ((f (second x))
                            (args (rest (rest x))))
                        (delete-duplicates (flatten (map 'list #'free `(,f . ,args))))))
       (let* (let* ((vars (map 'list #'first (second x)))
                    (vars* (map 'list #'second vars))
                    (body (rest (rest x))))
               (set-difference (free body) vars*)))
       (define* (let ((name (second (second x)))
                      (exp (third x)))
                  (set-difference (free exp) (list name))))
       (t (let ((f (first x))
                (args (rest x)))
            (delete-duplicates (flatten (map 'list #'free `(,f . ,args))))))))))


(defun transform-bottom-up (f x)
  (defun transform (x*) (transform-bottom-up f x*))
  (let ((x*
          (case (first x)
            (i32 x)
            (variable x)
            (lambda% (let ((params (second x))
                          (retty (third x))
                          (body (rest (rest (rest x)))))
                      `(lambda% ,params ,retty ,@(map 'list #'transform body))))
            (let% (let ((vars (map 'list #'first (second x)))
                        (exps (map 'list #'second (second x)))
                        (body (rest (rest (rest x)))))
                    `(let* ,(map 'list #'(lambda (var exp)
                                           `(,var ,(transform exp))) vars exps)
                       ,@(map 'list #'transform body))))
            (define% (let ((var (second x))
                           (exp (third x)))
                       `(define* ,var ,(transform exp))))
            (lambda* (let ((params (second x))
                           (retty (third x))
                           (body (rest (rest (rest x)))))
                       `(lambda* ,params ,retty ,@(map 'list #'transform body))))
            (make-closure (let ((lam (second x))
                                (env (third x)))
                            `(make-closure ,(transform lam) ,(transform env))))
            (make-env (let ((id (second x))
                            (vs (map 'list #'car (rest (rest x))))
                            (es (map 'list #'cdr (rest (rest x)))))
                        `(make-env ,id ,@(pairlis vs (map 'list #'transform es)))))
            (env-ref (let ((env-var (second x))
                           (v (third x)))
                       `(env-ref ,env-var ,v)))
            (apply-closure (let ((f (second x))
                                 (args (rest (rest x))))
                             `(apply-closure ,(transform f)
                                             ,@(map 'list #'transform args))))
            (let* (let ((vars (map 'list #'first (second x)))
                        (exps (map 'list #'second (second x)))
                        (body (rest (rest x))))
                    `(let* ,(map 'list
                                 #'(lambda (var exp)
                                     `(,var ,(transform exp))) vars exps)
                       ,@(map 'list #'transform body))))
            (define* (let ((var (second x))
                           (exp (third x)))
                       `(define* ,var ,(transform exp))))
            (t (let ((f (first x))
                     (args (rest x)))
                 `(,(transform f) ,@(map 'list #'transform args)))))))
    (funcall f x*)))

(defun flat-closure-convert (x)
  (transform-bottom-up #'closure-convert x))
