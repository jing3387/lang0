(in-package #:satori)

(defun recon (x ctx)
  (cond
    ((integerp x) '(integer ()))
    ((symbolp x) (let ((type (cdr (assoc x ctx))))
                   `(,type ())))
    ((case (first x)
       (lambda (let* ((param (first (second x)))
                      (body (first (rest (rest x)))))
                 (if (and (listp param) (second param))
                     (let* ((param-type (second param))
                            (ctx* (acons (car param) `(id ,param-type) ctx))
                            (body-recon (recon body ctx*))
                            (body-type (first body-recon))
                            (body-constr (second body-recon)))
                       `((f ,param-type ,body-type) ,body-constr))
                     (let* ((param-type `(id ,(gensym "T")))
                            (ctx* (acons param param-type ctx))
                            (body-recon (recon body ctx*))
                            (body-type (first body-recon))
                            (body-constr (second body-recon)))
                       `((f ,param-type ,body-type) ,body-constr)))))
       (t (let* ((x1 (first x))
                 (x2 (second x))
                 (recon1 (recon x1 ctx))
                 (recon2 (recon x2 ctx))
                 (type1 (first recon1))
                 (type2 (first recon2))
                 (constr1 (second recon1))
                 (constr2 (second recon2))
                 (type-ret `(id ,(gensym "T")))
                 (constr3 `((,type1 (f ,type2 ,type-ret)))))
            `(,type-ret ,(append constr3 constr1 constr2))))))))

(defun subst-type (tyX tyT tyS)
  (defun f (tyS)
    (cond
      ((equal tyS 'integer) 'integer)
      ((case (first tyS)
         (id (let ((s (second tyS)))
               (if (equal s tyX)
                   tyT
                   `(id ,s))))
         (f (let ((tyS1 (second tyS))
                  (tyS2 (third tyS)))
              `(f ,(f tyS1) ,(f tyS2))))))))
  (f tyS))

(defun apply-subst (constr tyT)
  (reduce #'(lambda (tyS x)
              (let ((tyX (second (first x)))
                    (tyC2 (second x)))
                (subst-type tyX tyC2 tyS)))
          (reverse constr)
          :initial-value tyT))

(defun subst-constr (tyX tyT constr)
  (map 'list
       #'(lambda (x)
           (let ((tyS1 (first x))
                 (tyS2 (second x)))
             `(,(subst-type tyX tyT tyS1) ,(subst-type tyX tyT tyS2))))
       constr))

(defun occurs-in (tyX tyT)
  (defun o (tyT)
    (cond
      ((equal tyT 'integer) nil)
      ((case (first tyT)
         (id (equal (second tyT) tyX))
         (f (let ((tyT1 (second tyT))
                  (tyT2 (third tyT)))
              (or (o tyT1) (o tyT2))))))))
  (o tyT))

(defun unify (constr)
  (defun u (constr)
    (let ((fst (first (first constr)))
          (snd (second (first constr))))
      (cond
        ((null constr) nil)
        ((equal fst snd) (u (rest constr)))
        ((and (listp snd)
              (case (first snd)
                (id (let ((tyS fst)
                          (tyX (second snd)))
                      (cond
                        ((equal tyS `(id ,tyX)) (u (rest constr)))
                        ((occurs-in tyX tyS)
                         (error 'satori-error :message "circular constraints"))
                        (t (append (u (subst-constr tyX tyS (rest constr)))
                                   `(((id ,tyX) ,tyS))))))))))
        ((and (listp fst)
              (case (first fst)
                (id (let ((tyX (second fst))
                          (tyT snd))
                      (cond
                        ((equal tyT `(id ,tyX)) (u (rest constr)))
                        ((occurs-in tyX tyT) (error 'satori-error
                                                    :message "circular constraints"))
                        (t (append (u (subst-constr tyX tyT (rest constr)))
                                   `(((id ,tyX) ,tyT)))))))
                (f (let* ((f1 fst)
                          (f2 snd)
                          (tyS1 (second f1))
                          (tyS2 (third f1))
                          (tyT1 (second f2))
                          (tyT2 (third f2)))
                     (u `((,tyS1 ,tyT1) (,tyS2 ,tyT2) ,@(rest constr))))))))
         (t (error 'satori-error :message "unsolvable constraints")))))
  (u constr))

(defun infer (x ctx constr)
  (let* ((recon (recon x ctx))
         (tyT (first recon))
         (constr* (second recon))
         (constr** (append constr constr*))
         (constr*** (unify constr**)))
    (apply-subst constr*** tyT)))
